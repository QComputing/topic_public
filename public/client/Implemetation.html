<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Algorithms</title>
    <!--TODO all the metas-->
    <meta name="description" content="An attempt to explain what Quantum Computing is about" />

    <!--Pretty fonts-->
    <link href="https://fonts.googleapis.com/css?family=Rubik" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet">

    <!--Our css-->
    <link rel="stylesheet" href="css/main.css">
    <!--Bootstrap-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


    <!--TODO refactor this section that just ease the creation-->
    <link rel="script" href="header.js">
</head>

<body>
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">

        <a class="navbar-brand" id="title" href="index.html"><img id="title_img" src="img/logo.png" alt="LogoQC">Quantum Computing: Implementation</a>

        <ul class="nav navbar-nav navbar-right">
            <li class="active"><a href="Physics.html">Physics</a></li>
            <li class="active"><a href="Logic.html">Implementation</a></li>
            <li class=""><a href="">Algorithms</a></li>
            <li class="active"><a href="Prospects.html">Prospects</a></li>
            <li class="active"><a href="References.html">References</a></li>
        </ul>

    </div>
</nav>

<div id="nav_margin"></div>

<!--Start SAMPLE-->
<div class="blog-header">
    <div class="container">
        <div class="row">
            <div class="col-sm-8">
                <h1 id="article_title">
                    Quantum Algorithm and Programming
                </h1>
                <p>
                    Implementation mean in Object Oriented Programming (OOP) that a class provide the methods specified in the interface. However, implementing is not specific to OOP and concerns more generally the realisation of algorithms; algorithms which once carefully programmed should output a result that fits a given problem.
                    To study the quantum implementation, it’s therefore important to work out the logic and algorithms that drive these machines and make them so powerful. We are used to multi-purpose computers that are easily reprogrammable, we need to go back to lower level of details to higher order programming language, this is the key in the development of QC and their implementation.
                </p>
                <h2>
                    Quantum Algorithms
                </h2>
                <p>
                    Algorithm exists from the dawn of computing. They are a sequence of steps that should lead to a logical, generally immutable, and meaningful outcome. We find computers better than humans to follow most algorithm as their capacity to calculate and treat data exceed us by far. However, even Gordon Moore (Moore, 1965) could not predict that we would go so small in the transistors that we would face the limits of the atom. As a consequence, the computing power on regular CPU is not likely to continue increasing as it has now. One of the flaw of those chips, especially in an era like ours where the Big Data is becoming so crucial, the analysis of such flow of information is going to be impossible. Another would be  the analysis of multiple factor that impact a phenomenon requires the analysis of each one of them varying separately (weather predictions, deciphering communication, etc.). The algorithms for QC take advantage of the fact QC can explore multiple solutions at once and therefore more capable of tackling today’s computing limitation. We'll go through some of those
                </p><br />
                <p>
                    <b>“Quantum mechanics can speed up a range of search applications over unsorted data.”</b> (Groover, 1997). Groover studied in his paper the problem of accessing an unsorted database of <i>N</i> states. On average you hope to only need to scan half of the database before finding the required entry, but in the worst case, you will scan all <i>N</i> entries of the database (<i>O(N)</i>). The Quantum algorithm uses properties of the amplitude of qubits. The algorithm can be described as follows:<br />
                    Only one item (<i>I</i>) in the database satisfies the property <i>P(I)=1</i>, for all the others states <i>S</i> we have <i>P(S)=0</i>.<br />
                    Initialise the system so each state has the same amplitude (superposition <img src="img/image001.png" />).<br/>
                    Say <img src="img/image002.png" /><br />
                    Apply the transformation <i>T</i> and if a state reaches <i>P(S) = 1</i>, rotate the phase by 180 degrees.<br/>
                    Note that the transformation <i>T</i> affects the amplitude of the states in such a way the desired one will stand out. The complexity of the loop and of the initialisation makes it a <img src="img/image004.png"/> , which is a gain of polynomial order (divided by two) compared to the classic algorithm.
                </p><br />
                <p>
                    On another note, QC are also very good at applying Fourrier's transform. The Discrete Fourier’s transform represents the frequency domain of the given input. It can be applied to quantum algorithms and implemented very efficiently, particularly useful for finding eigenvalue of unitary operators and probably its most famous application is the use in Shor’s algorithm.
                </p>
                <p>
                    Shor’s algorithm has become very famous over the years as its realisation, if it should come, will affect radically the domain of communication and cryptography that protects everyone’s privacy. Decrypting an RSA transaction to a bank to retrieve the credit cards info could be done in polynomial time –in terms of log n- instead of exponential time leaving many systems at risk.<br/>
                    The factorisation algorithm of a number <i>N</i> consists like many Quantum algorithms of a classic routine run on a regular computer, that routine triggers at some point a quantum subroutine, but the process is originally controlled by a regular computer. The main advantage of this method is that it allows to save resources on both machines as they are used to what they are the most efficient for. The Quantum routine is very specialised and only serves as finding the order of an element; its efficiency results in the ability to search a remaining square root of different from 1 and -1.<br />
                    We are sure this root exists, as stated by the Chinese remainder theorem. Finding such a number <i>S</i> and taking <i>d = gdc(S-1, N)</i>  implies that <i>d</i> will be a proper factor of N (different from 0 and <i>N</i>).
                    Indeed <i>d</i> is proper because:
                </p>
                <ul>
                    <li>If <i>d = 1</i>, then by Bézout’s theorem, <i>&#8707; u, v</i> such that <i>u(S-1) + vN = 1</i><br />
                        Leading by a multiplication by <i>S - 1</i> on both sides that <i>N | S+1</i> which contradicts how we obtained <i>S</i> (<i>S</i> is not congruent to -1 mod N).</li>
                    <li>If <i>d = N</i>, then <i>N | S-1 </i>which also contradicts how we obtained <i>S</i> (<i>S</i> is not congruent to 1 mod <i>N</i>).</li>
                </ul>
                <p>
                    Therefore we <i>d</i> is a proper factor for <i>N</i>.<br/>
                    The algorithm to find such an S is as follows:
                </p>
                <ol>
                    <li>Pick a random number <i>a < N</i></li>
                    <li>If  <i>gcd(a, N) &#8800; 1</i> return  <i>a</i></li>
                    <li>Else find the order <i>r</i> of <i>a</i> in the group of integer with the operation of multiplication and if <i>r</i> is congruent to 1 mod 2 or if<i> a </i> to the power of <i> r/2 </i> is equal to -1 or 1 mod <i>N</i>, go back to step 1</li>
                    <li>Else we have found our S!</li>
                </ol>
                <p>
                    This algorithm will probably be implemented very efficiently one day. Researchers have for now mostly limited themselves to factorising the number 15 (probably the smallest non-trivial test for Shor’s algorithm), probably the 256-bits keys of the Advanced Encryption Standard. But it’s probably one of the biggest success for QC which demonstrate their capacity on one the most complex Quantum algorithm that exists until these days. If Quantum Computer comes out, smaller keys may even be factorable from personal machines.
                </p>
                <br />
                <p>
                    QC algorithms are groundbreaking and will probably change many aspects of computing, however, to make them scalable, and not device specific, we will need to have a general-purpose programming language in order to program them.
                </p>
                <h2>
                    Towards Quantum Programming Languages
                </h2>
                <p>
                    For a computer to be truly useful and game changer, it is important to be able to program it. From the first “Hello, Quantum World” (which may be more difficult than it looks like), to Shor’s algorithm, programmers need to be able to express their ideas to the machine. Powerful and diverse programming languages could inspire generation of programmers to accomplish great things with their ‘PQ’ (Personal Quomputer?).
                </p><br />
                    The first approach to programming may be a precise <b>pseudo-code</b>. It should be clear and intuitive but have a well-defined shared logic that don’t leave room for interpretation.<br/>
                    The Convention for a Quantum Pseudocode (Knill) written in 1996 stands as a monolith in the field. It reuses classic and expected patterns from classic computing (like if evaluates the ket 1 as true, or the for loops behaves as expected).<br/>
                    It also achieves the simplification of recurrent operations like the Hadamard operation on a Qubit <i> a </i> or the phase shift using letter and classic function application like <i> H(a) </i> for the application of the Hadamard matrix on the qubit <i> a</i>.<br />
                    Measurements use simple inverted arrows like <i>a <-- a </i> and functions and methods are qualified by their names.<br />
                    Note how it is therefore possible to write down pseudo code without a powerful text editor.
                </p><br />
                <p>
                    Now that code can be expressed formally, programming languages can have precise logical specification. As it’s possible to expect, there exists two types of Quantum Programming Languages (QPL), imperative and functional. There exists already plenty of different QPL even though the need for the moment would be the actual quantum computer. Many QPLs are based from pre-existing programming languages.<br/>
                    For example Q is an extension of C++, it can therefore use the multiple libraries and makes it easy to reuse chunks of code that nay already exist today. Also, there is no need to start a compiler from scratch, unlike some trials that existed before like Omer’s QCL. However they happen to share some features, the most interesting one could be the representation of the data. The language expect a Quantum heap on to which the Quantum registers would hold a reference to the different qubit that would to stored on it.<br />
                    Haskell, so loved at Imperial College, also happen to be Quantum ready! There is a Haskell package called QIO that draw the bases of what an implementation of QHaskell would look like. For the most interested, follow this link for an implementation of Shor’s algorithm using QIO package given in the example of the package. More recently, The QPL Quipper developed in the recent years and provides all the tools to expect from a QPL but wrapped up in Haskell’s solid type system and suitable for monadic instructions, making it a very powerful tool for tomorrow’s programmers.<br/>
                </p>
            </div>
        </div>
    </div>
</div>
<div style="height: 100px;"></div>
</body>
</html>